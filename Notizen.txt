- Rechtemodell: Von Außen (zb aus der main) darf nur auf public zugegriffen werden, egal
ob ein Object instanziiert ist oder nicht. Wird nun eine Public Funktion aufgerufen kann 
innerhalb dieser Funktion auf alles zugegriffen werden. Zudem kann auf die protected 
Elemente der höheren Klasse zugegriffen werden. 
Aber warum braucht es im Skript Beispiel dann eine fried deklaration um auf Elemente der 
Klasse zuzugreifen. 




- Nachdem eine Funktion oder Variable als const gekennzeichnet wurde müssen die objects komplett
neu gebaut werden, sonst kann gcc das ganze nicht binden

- private nur von der Klasse zu sehen, proteced von Unterklassen zugängig und public von jedem. 
Man möchte die höchste Sicherheit um später beim debuggen das Problem einschränken zu können. 
Daher alles auf private setzen und den Zugriff über public Funktionen erlauben. Außnahme machen 
Variablen die in abgeleiteten Klassen verwendet werden sollen, diese müssen auch dort sichtbar 
sein und daher als protected initialisiert werden. 

- In eine Header am Anfang #ifndef HEADERNAME_H   #define HEADERNAME_H und ans ende #endif. So 
kann man die Header aus versehen zweimal irgendwo einbinden ohne das es problematisch wird.


- Um eine rein Virtuelle Funktion zu implementieren setzt man "= 0" hinter die Definition, dann
wird allerdings automatisch die ganze Klasse virtuel


- Eine Static Variable wird jeweils nur einmal für alle Objekte der Klasse angelegt, eine static
  Variable oder function außerhalb von Klasse bedeutet das gegenteil von extern und sorgt dafür,
  das die Variable oder function nur aus dem aktuellen scope sichtbar ist. 

- Innerhalb von Header sollte kein namespace std deklariert werden, da das ganze sonst in die cpp
wandert. Daher in der Header einfach std:: davor schreiben. 

- Die header inkludierung muss in der gleichen Reihenfolge passieren wie die initialisierung die 
abfolge der Klassenhirarchie selbst, sonst werden die Elemente der Äußeren Klasse in der inneren
nicht gefunden. 


- Ein Pointer enthält die Adresse, also eine Zahl die für einen Speicherbereich steht. Diese Adresse
wird einfach hochgezählt, sprich ein Array mit 10 Elementen enthäl 10 nebeneinander liegende Adressen, 
egal wieviel byte der gespeicherte Datentyp enthält. 
Stimmt das? Wie kann ich dann auf zb einem Array von Structs zugreifen? Kann das nur als Pointer gespeichert werden?









array[5]=...
array == *array[0]
array[i] == *(array + i)          // Warum? array enthält doch schon die Adresse, warum eine Referenz mehr? 
